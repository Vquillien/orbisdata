/**
 * OrbisGIS is a java GIS application dedicated to research in GIScience.
 * OrbisGIS is developed by the GIS group of the DECIDE team of the
 * Lab-STICC CNRS laboratory, see <http://www.lab-sticc.fr/>.
 *
 * The GIS group of the DECIDE team is located at :
 *
 * Laboratoire Lab-STICC – CNRS UMR 6285
 * Equipe DECIDE
 * UNIVERSITÉ DE BRETAGNE-SUD
 * Institut Universitaire de Technologie de Vannes
 * 8, Rue Montaigne - BP 561 56017 Vannes Cedex
 *
 * OrbisGIS is distributed under GPL 3 license.
 *
 * Copyright (C) 2015-2017 CNRS (Lab-STICC UMR CNRS 6285)
 *
 * This file is part of OrbisGIS.
 *
 * OrbisGIS is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OrbisGIS is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OrbisGIS. If not, see <http://www.gnu.org/licenses/>.
 *
 * For more information, please consult: <http://www.orbisgis.org/>
 * or contact directly:
 * info_at_ orbisgis.org
 */
package org.orbisgis.orbisdata.filter.fes_2_0_2;

import net.opengis.fes._2_0_2.*;
import javax.xml.bind.JAXBElement;
import java.util.Iterator;
import java.util.List;


/**
 * This class change a JaxB object in SQL parameter.
 * @Author Vincent QUILLIEN
 */
public class FesToSql {

    /**
     * This method take an object generated by JaxB from a xml file and give un return the SQL parameter.
     * @param objectFromFilterXml
     * @return the SQL parameter
     */
    public static StringBuilder XmlToSql(Object objectFromFilterXml ){
        StringBuilder returnSQL = new StringBuilder();

        if (objectFromFilterXml instanceof JAXBElement) {
            // first node : One branch for Filter and one for SortBy
            switch (((JAXBElement) objectFromFilterXml).getName().getLocalPart()){

                case "Filter":
                    FilterType filterType = (FilterType) ((JAXBElement) objectFromFilterXml).getValue();
                    // know the type of operator
                    if (filterType.isSetComparisonOps()) {
                        JAXBElement<ComparisonOpsType> comparisonElement = (JAXBElement<ComparisonOpsType>) filterType.getComparisonOps();
                        returnSQL.append(operatorComparison(comparisonElement));

                    } else if (filterType.isSetSpatialOps()) {
                        JAXBElement<SpatialOpsType> spatialElement = (JAXBElement<SpatialOpsType>) filterType.getSpatialOps();
                        returnSQL.append(operatorSpatial(spatialElement));

                    } else if (filterType.isSetLogicOps()) {
                        JAXBElement<LogicOpsType> logicalElement = (JAXBElement<LogicOpsType>) filterType.getLogicOps();
                        returnSQL.append(operatorLogical(logicalElement));

                    } else if (filterType.isSetFunction()) {
                        ObjectFactory factory = new ObjectFactory();
                        JAXBElement<FunctionType> functionElement = factory.createFunction(filterType.getFunction());
                        returnSQL.append(operatorFunction(functionElement));

                    } else if (filterType.isSetId()) {
                        JAXBElement<ResourceIdType> resourceId = (JAXBElement<ResourceIdType>) filterType.getId();
                        returnSQL.append(operatorId(resourceId));

                    } else if (filterType.isSetExtensionOps()) {
                        ExtensionOpsType extensionOperator = filterType.getExtensionOps();
                        returnSQL.append(operatorExtension(extensionOperator));

                    } else if (filterType.isSetTemporalOps()) {
                        //not required
                    }
                    break;
                case "SortBy":
                    SortByType sortByType = (SortByType) ((JAXBElement) objectFromFilterXml).getValue();

                    if (sortByType.isSetSortProperty()) {
                        List<SortPropertyType> listProperty = sortByType.getSortProperty();
                        Iterator<SortPropertyType> listPropertyIterator = listProperty.iterator();

                        while (listPropertyIterator.hasNext()) {
                            SortPropertyType property = listPropertyIterator.next();

                            if (listPropertyIterator.hasNext() && property.isSetSortOrder()) {
                                returnSQL.append(property.getValueReference());
                                returnSQL.append(property.getSortOrder().value() + ", ");

                            } else if (listPropertyIterator.hasNext() && !(property.isSetSortOrder())) {
                                returnSQL.append(property.getValueReference() + ", ");

                            } else if (!(listPropertyIterator.hasNext()) && (property.isSetSortOrder())) {
                                returnSQL.append(property.getValueReference() + " ");
                                returnSQL.append(property.getSortOrder());

                            } else {
                                returnSQL.append(property.getValueReference());
                            }
                        }
                    }
                    break;
            }

        }
        return returnSQL;
    }

//------------------------------------------------Operator Comparison-------------------------------------------------

    /**
     * Method separate the comparison object for each comparison operator
     * @param comparisonElement
     * @return
     */
    private static StringBuilder operatorComparison(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();


        if (comparisonElement.getName().getLocalPart().equals("PropertyIsBetween")) {
            returnSQL.append(operatorPropertyIsBetween(comparisonElement));

        } else if (comparisonElement.getName().getLocalPart().equals("PropertyIsLike")) {
            returnSQL.append(operatorPropertyIsLike(comparisonElement));

        } else if (comparisonElement.getName().getLocalPart().equals("PropertyIsNil")) {
            returnSQL.append(operatorPropertyIsNil(comparisonElement));

        } else if (comparisonElement.getName().getLocalPart().equals("PropertyIsNull")) {
            returnSQL.append(operatorPropertyIsNull(comparisonElement));

        } else {
            returnSQL.append(operatorBinaryComparison(comparisonElement));
        }
        return returnSQL;
    }

    /**
     * Method create the String returned for the object of type PropertyIsBetween
     * @param comparisonElement
     * @return
     */
    private static StringBuilder operatorPropertyIsBetween(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        PropertyIsBetweenType propertyIsBetweenType = (PropertyIsBetweenType) comparisonElement.getValue();
        JAXBElement lowerBoundary = propertyIsBetweenType.getLowerBoundary().getExpression();
        JAXBElement upperBoundary = propertyIsBetweenType.getUpperBoundary().getExpression();

        if (propertyIsBetweenType.isSetExpression()) {
            returnSQL.append(getExpressionRecursive(propertyIsBetweenType.getExpression()));
            returnSQL.append("BETWEEN ");

            if (propertyIsBetweenType.isSetLowerBoundary())
                returnSQL.append(getExpressionRecursive(lowerBoundary));

            if (propertyIsBetweenType.isSetUpperBoundary())
                returnSQL.append(getExpressionRecursive(upperBoundary));

        } else returnSQL.append("The column isn't defined");
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type PropertyIsLike
     * @param comparisonElement
     * @return
     */
    private static StringBuilder operatorPropertyIsLike(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        PropertyIsLikeType propertyIsLikeType = (PropertyIsLikeType) comparisonElement.getValue();
        if (propertyIsLikeType.isSetExpression()) {
            List<JAXBElement<?>> list = propertyIsLikeType.getExpression();

            for (JAXBElement element : list) {
                returnSQL.append(getExpressionRecursive(element));

                if (list.get(0) == element) {
                    returnSQL.append("LIKE ");
                }
            }
        }
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type PropertyIsNil
     * @param comparisonElement
     * @return
     */
    private static StringBuilder operatorPropertyIsNil(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        PropertyIsNilType propertyIsNilType = (PropertyIsNilType) comparisonElement.getValue();

        if (propertyIsNilType.isSetExpression()) {
            returnSQL.append(getExpressionRecursive(propertyIsNilType.getExpression()));
            returnSQL.append("IS NIL");
        }
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type PropertyIsNull
     * @param comparisonElement
     * @return
     */
    private static StringBuilder operatorPropertyIsNull(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        PropertyIsNullType propertyIsNullType = (PropertyIsNullType) comparisonElement.getValue();

        if (propertyIsNullType.isSetExpression()) {
            returnSQL.append(getExpressionRecursive(propertyIsNullType.getExpression()));
            returnSQL.append("IS NULL");
        }
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type BinaryComparison
     * @param comparisonElement
     * @return
     */
    private static StringBuilder operatorBinaryComparison(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        //type BinaryComparisonOpType
        BinaryComparisonOpType binaryComparisonOpType = (BinaryComparisonOpType) comparisonElement.getValue();

        if (binaryComparisonOpType.isSetExpression()) {
            List<JAXBElement<?>> list = binaryComparisonOpType.getExpression();

            for (JAXBElement element : list) {
                returnSQL.append(getExpressionRecursive(element));

                if (list.get(0) == element) {

                    switch (comparisonElement.getName().getLocalPart()) {
                        case "PropertyIsGreaterThan":
                            returnSQL.append("> ");
                            break;
                        case "PropertyIsLessThan":
                            returnSQL.append("< ");
                            break;
                        case "PropertyEqualTo":
                            returnSQL.append("= ");
                            break;
                        case "PropertyIsNotEqualTo":
                            returnSQL.append("!= ");
                            break;
                        case "PropertyIsLessThanOrEqualTo":
                            returnSQL.append("<= ");
                            break;
                        case "PropertyIsGreaterThanOrEqualTo":
                            returnSQL.append(">= ");
                            break;
                    }
                }
            }
        }
        return  returnSQL;
    }


//-----------------------------------------------Operator Spatial-------------------------------------------------------

    /**
     * Method separate the Spatial object for each Spatial Operator
     * @param spatialElement
     * @return
     */
    private static StringBuilder operatorSpatial(JAXBElement<SpatialOpsType> spatialElement){
        StringBuilder returnSQL = new StringBuilder();


        if (spatialElement.getName().getLocalPart().equals("BBOX")) {
            BBOXType bbox = (BBOXType) spatialElement.getValue();
            if (bbox.isSetExpressionOrAny()) {
                returnSQL.append(operatorBBOX(bbox));
            }
        } else if (spatialElement.getName().getLocalPart().equals("Beyond") || spatialElement.getName().getLocalPart().equals("DWithin")) {
            DistanceBufferType distanceBuffer = (DistanceBufferType) spatialElement.getValue();
            if(distanceBuffer.isSetExpressionOrAny()){
                returnSQL.append(operatorDWithin(distanceBuffer));
            }
        } else {
            BinarySpatialOpType binarySpatialOp = (BinarySpatialOpType) spatialElement.getValue();
            if (binarySpatialOp.isSetExpressionOrAny()) {
                returnSQL.append(operatorBinarySpatial(binarySpatialOp, spatialElement));
            }
        }
        return  returnSQL;
    }


    /**
     * Method create the String returned for the object type BBOX. This operator can be transform in a two function,
     * a not and a Disjoint.
     * @param bboxType
     * @return
     */
    private static StringBuilder operatorBBOX( BBOXType bboxType) {
        StringBuilder returnSQL = new StringBuilder();
        returnSQL.append("!( ST_Disjoint( ");
        List<Object> list = bboxType.getExpressionOrAny();
        for (Object obj : list) {
            if (obj instanceof JAXBElement) {
                returnSQL.append(getExpressionRecursive((JAXBElement) obj));
            }
            else{
                returnSQL.append(obj.toString());
            }
            if(list.get((list.size()-1))!=obj)returnSQL.append(", ");
        }
        returnSQL.append(")");
        return returnSQL;
    }


    /**
     * Method create the String returned for the object of type DWithin
     * @param distanceBuffer
     * @return
     */
    private static StringBuilder operatorDWithin(DistanceBufferType distanceBuffer) {
        StringBuilder returnSQL = new StringBuilder();
        List<Object> list = distanceBuffer.getExpressionOrAny();
        returnSQL.append("ST_DWithin( ");
        for (Object obj : list) {
            if (obj instanceof JAXBElement) {
                JAXBElement element = ((JAXBElement) obj);
                returnSQL.append(getExpressionRecursive(element));
                returnSQL.append(", ");
            }
        }
        returnSQL.append(distanceBuffer.getDistance().getValue()+" ");
        returnSQL.append(")");
        return returnSQL;
    }

    /**
     * Method create the String returned for the object of type BinarySpatialOp
     * @param binarySpatialOp
     * @param spatialElement
     * @return a StringBuilder
     */
    private static StringBuilder operatorBinarySpatial(BinarySpatialOpType binarySpatialOp,JAXBElement<SpatialOpsType> spatialElement ) {
        StringBuilder returnSQL = new StringBuilder();
        List<Object> list = binarySpatialOp.getExpressionOrAny();

        for (Object obj : list) {
            if (obj instanceof JAXBElement) {

                if (list.get(0) == obj) {//if beginning of list

                    switch (spatialElement.getName().getLocalPart()) {
                        case "Equals":
                            returnSQL.append("ST_Equals( ");
                            break;
                        case "Disjoint":
                            returnSQL.append("ST_Disjoint( ");
                            break;
                        case "Touches":
                            returnSQL.append("ST_Touches( ");
                            break;
                        case "Overlaps":
                            returnSQL.append("ST_Overlaps( ");
                            break;
                        case "Crosses":
                            returnSQL.append("ST_Crosses( ");
                            break;
                        case "Intersects":
                            returnSQL.append("ST_Intersects( ");
                            break;
                        case "Contains":
                            returnSQL.append("ST_Contains( ");
                            break;
                        case "Within":
                            returnSQL.append("ST_Within( ");
                            break;
                    }
                }
            } else {
                returnSQL.append(" " + obj.toString() + " ");
            }
            JAXBElement element = ((JAXBElement) obj);
            returnSQL.append(getExpressionRecursive(element));
            if(list.get((list.size()-1))!=obj)returnSQL.append(", ");// if end of list
        }
        returnSQL.append(")");
        return returnSQL;
    }


//------------------------------------------------Operator Logical------------------------------------------------------

    /**
     * Method separate the Logical object for each Spatial Logical
     * @param logicalElement
     * @return
     */
    private static StringBuilder operatorLogical(JAXBElement<LogicOpsType> logicalElement){
        StringBuilder returnSQL = new StringBuilder();

        if (logicalElement.getName().getLocalPart().equals("Not")) {
            returnSQL.append(operatorNot(logicalElement));
        } else {
            BinaryLogicOpType binaryLogicOpType = (BinaryLogicOpType) logicalElement.getValue();
            String ops = logicalElement.getName().getLocalPart();
            returnSQL.append(operatorOrAnd(binaryLogicOpType,ops));
        }
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type UnaryLogic
     * @param logicalElement
     * @return
     */
    private static StringBuilder operatorNot(JAXBElement<LogicOpsType> logicalElement){
        StringBuilder returnSQL = new StringBuilder();
        UnaryLogicOpType unaryLogic = (UnaryLogicOpType) logicalElement.getValue();
        returnSQL.append("!( ");
        if (unaryLogic.isSetComparisonOps()) {
            JAXBElement<ComparisonOpsType> comparisonElement = (JAXBElement<ComparisonOpsType>) unaryLogic.getComparisonOps();
            returnSQL.append(operatorComparison(comparisonElement));

        } else if (unaryLogic.isSetSpatialOps()) {
            JAXBElement<SpatialOpsType> spatialElement = (JAXBElement<SpatialOpsType>) unaryLogic.getSpatialOps();
            returnSQL.append(operatorSpatial(spatialElement));

        } else if (unaryLogic.isSetLogicOps()) {
            JAXBElement<LogicOpsType> logicalElementRecursif = (JAXBElement<LogicOpsType>) unaryLogic.getLogicOps();
            returnSQL.append(operatorLogical(logicalElementRecursif));//

        } else if (unaryLogic.isSetFunction()) {
            ObjectFactory factory = new ObjectFactory();
            JAXBElement<FunctionType> functionElement = factory.createFunction(unaryLogic.getFunction());
            returnSQL.append(operatorFunction(functionElement));

        } else if (unaryLogic.isSetId()) {
            JAXBElement<ResourceIdType> resourceId = (JAXBElement<ResourceIdType>) unaryLogic.getId();
            returnSQL.append(operatorId(resourceId));

        } else if (unaryLogic.isSetExtensionOps()) {
            ExtensionOpsType extensionOperator = unaryLogic.getExtensionOps();
            returnSQL.append(operatorExtension(extensionOperator));

        } else if (unaryLogic.isSetTemporalOps()) {
            //not required
        }
        returnSQL.append(") ");
        return returnSQL ;
    }

    /**
     * Method create the String returned for the object of type BinaryLogic
     * @param binaryLogicOpType
     * @param ops
     * @return
     */
    private static StringBuilder operatorOrAnd(BinaryLogicOpType binaryLogicOpType,String ops) {
        StringBuilder returnSQL = new StringBuilder();

        if (binaryLogicOpType.isSetComparisonOpsOrSpatialOpsOrTemporalOps()) {
            returnSQL.append("( ");
            List<JAXBElement<?>> list = binaryLogicOpType.getComparisonOpsOrSpatialOpsOrTemporalOps();
            for (JAXBElement element : list) {

                if(element==list.get((list.size()-1)))returnSQL.append(ops+" ");

                if(element.getValue() instanceof ComparisonOpsType){
                    returnSQL.append(operatorComparison(element));

                }else if(element.getValue() instanceof SpatialOpsType){
                    returnSQL.append(operatorSpatial(element));

                }else if(element.getValue() instanceof LogicOpsType){
                    returnSQL.append(operatorLogical(element));

                }else if(element.getValue() instanceof FunctionType){
                    returnSQL.append(operatorFunction(element));

                }else if(element.getValue() instanceof ExtensionOpsType){
                    returnSQL.append(operatorExtension((ExtensionOpsType) element.getValue()));

                }else if(element.getValue() instanceof ResourceIdType){
                    returnSQL.append(operatorId(element));

                }else if(element.getValue() instanceof TemporalOpsType){
                    // not implement yet
                }
            }
            returnSQL.append(") ");
        }
        return returnSQL;
    }


//-----------------------------------------------Operator Function------------------------------------------------------

    /**
     * Method create the String returned for the object of type Function
     * @param functionElement
     * @return
     */
    private static StringBuilder operatorFunction(JAXBElement<FunctionType> functionElement){
        StringBuilder returnSQL = new StringBuilder();
        returnSQL.append(getExpressionRecursive(functionElement));
        returnSQL.append(")");
        return  returnSQL;
    }


//-----------------------------------------------Operator Id------------------------------------------------------------

    /**
     * Method create the String returned for the object of type Function
     * @param resourceIdElement
     * @return
     */
    private static StringBuilder operatorId(JAXBElement<ResourceIdType> resourceIdElement){
        StringBuilder returnSQL = new StringBuilder();
        ResourceIdType resourceId = resourceIdElement.getValue();
        //not Implement yet
        return  returnSQL;
    }


//-----------------------------------------------Operator Extension------------------------------------------------------

    /**
     * Method create the String returned for the object of type Extension
     * @param extensionOperator
     * @return
     */
    private static StringBuilder operatorExtension(ExtensionOpsType extensionOperator){
        StringBuilder returnSQL = new StringBuilder();
        //not Implement yet
        return  returnSQL;
    }


//----------------------------------------------------Expression--------------------------------------------------------

    /**
     * Method create the String returned for the Expression
     * @param element
     * @return
     */
    private static StringBuilder getExpressionRecursive(JAXBElement element){
        StringBuilder stringBuilder = new StringBuilder();

        if(element.getName().getLocalPart().equals("Function")){
            FunctionType functionType = (FunctionType) element.getValue();
            stringBuilder.append(functionType.getName()+"( ");

            List<JAXBElement<?>> listExpression = functionType.getExpression();
            for(JAXBElement exp : listExpression){
                stringBuilder.append(getExpressionRecursive(exp));
                if (listExpression.get((listExpression.size()-1)) != exp) {
                    stringBuilder.append(", ");
                }
            }

        }else if(element.getName().getLocalPart().equals("ValueReference")) {
            stringBuilder.append(element.getValue().toString()+" ");

        }else if(element.getName().getLocalPart().equals("Literal")) {
            element = (JAXBElement<LiteralType>) element;
            LiteralType literalType = (LiteralType) element.getValue();
            List list = literalType.getContent();

            for(Object obj : list){
                stringBuilder.append(obj.toString()+" ");
            }

        }else{
            stringBuilder.append(" "+element.getValue().toString()+" ");
        }

        return stringBuilder;
    }
}